from Crypto.Util.number import getStrongPrime
from GET_PARAMS import get_params_for_pedersen
from random import randint, sample
import logging
from functools import reduce
from GET_KEY import get_key_by_eq, get_key_by_lagrange_interpolation

logging.basicConfig(level=logging.INFO, format="[%(levelname)s] %(message)s")
logger = logging.getLogger("Pedersen Protocol")


T = 6
N = 12
Q = getStrongPrime(512)
LENGTH_P = 1024
P, G, H = get_params_for_pedersen(Q, LENGTH_P)


def create_users(N):
    # Создаем пользователей
    users = list()
    for _ in range(N):
        users.append(PedersenUser(T, N))
    return users


def set_user_points(users, dealer) -> None:
    # Иницилизация точек среди пользователей
    for index, user in enumerate(users):
        point = dealer.get_point(index)
        user.set_point(point)


def set_params(dealer, users) -> None:
    # Задаем коэффициенты и значения, по факту выбираем многочлен
    dealer.set_delta_coefficients()
    dealer.set_values()
    dealer.set_gamma_coefficients()
    dealer.set_verify_values()
    for index, user in enumerate(users):
        point = dealer.get_value(index)
        user.set_value(point)
        w = dealer.get_w(index + 1)
        user.set_w(w)
        verify_values = dealer.get_verify_values()
        user.set_verify_values(verify_values)


def custom_validation(users) -> None:
    # Проверяем полученные части ключа
    for user in users:
        user.check()


def restore_keys(users, dealer, T):
    # восстанавливаем ключ двумя методами
    # сообщаем об успехе/провале
    def print_results(resp):
        if resp:
            logger.info("Key assembly completed successfully")
            logger.info(f"Received key: {result}")
            logger.info(f"Generated by dealer key: {dealer.get_key()}")
        else:
            logger.info("The resulting key is different from the generated one")
            logger.info(f"Received key: {result}")
            logger.info(f"Generated by dealer key: {dealer.get_key()}")
    users_for_verify = sample(users, T)
    logger.info("SOLVING EQUATIONS")
    result = get_key_by_eq(users_for_verify, Q)
    if result:
        print_results(result == dealer.get_key())
    logger.info("LAGRANGE INTERPOLATION")
    result = get_key_by_lagrange_interpolation(users_for_verify, Q)
    print_results(result == dealer.get_key())


def key_sharing():
    # разделям секрет и собираем
    dealer = PedersenDealer(T, N)
    users = create_users(N)
    dealer.set_points()
    set_user_points(users, dealer)
    set_params(dealer, users)
    custom_validation(users)
    restore_keys(users, dealer, T)
    logger.info("-" * 100)
    restore_keys(users, dealer, T-1)


def multiply_list_elements(data):
    # перемножаем элементы в списке
    return reduce(lambda x, y: x * y, data)


class PedersenDealer:
    # класс дилера
    def __init__(self, t, n):
        self._t = t
        self._n = n
        self._points = list()
        self._delta_coefficients = list()
        self._gamma_coefficients = list()
        self._values = list()
        self._verify_values = list()
        self._key = None

    def set_points(self) -> None:
        # задаем точки
        for point in range(1, self._n + 1):
            self._points.append(point)

    def get_point(self, index):
        return self._points[index]

    @staticmethod
    def get_random_element(P):
        return randint(2, P - 2)

    def set_key(self) -> None:
        self._key = self.get_random_element(Q)

    def get_key(self):
        return self._key

    def get_value(self, index):
        return self._values[index]

    def set_delta_coefficients(self) -> None:
        # генерируем коэффициенты
        self.set_key()
        self._delta_coefficients.append(self._key)
        for _ in range(self._t - 1):
            self._delta_coefficients.append(self.get_random_element(Q))

    def get_delta_coefficients(self):
        return self._delta_coefficients

    def set_values(self) -> None:
        # получаем значения от коэффициентов
        for point in self._points:
            prev = list()
            for power, coefficient in enumerate(self._delta_coefficients):
                prev.append(coefficient * (point ** power))
            self._values.append(sum(prev) % Q)

    def set_gamma_coefficients(self) -> None:
        # генерируем коэффициенты
        for _ in range(self._t):
            self._gamma_coefficients.append(self.get_random_element(Q))

    def get_gamma_coefficients(self):
        return self._gamma_coefficients

    def set_verify_values(self) -> None:
        # получаем проверочные значения от гамма и дельта коэффициентов
        for delta, gamma in zip(self._delta_coefficients, self._gamma_coefficients):
            self._verify_values.append((G ** delta) * (H ** gamma))

    def get_verify_values(self):
        return self._verify_values

    def get_w(self, val):
        # вычисляем параметры для проверки частей ключа
        list_for_sum = list()
        for power, g in enumerate(self._gamma_coefficients):
            list_for_sum.append(g * pow(val, power))
        return sum(list_for_sum)


class PedersenUser:
    # класс пользователя
    def __init__(self, t, n):
        self._t = t
        self._n = n
        self._point = None
        self._value = None
        self._verify_values = None
        self._w = None

    def set_point(self, point) -> None:
        self._point = point

    def get_point(self):
        return self._point

    def set_value(self, value) -> None:
        self._value = value

    def get_value(self):
        return self._value

    def set_verify_values(self, verify_values) -> None:
        self._verify_values = verify_values

    def get_verify_values(self):
        return self._verify_values

    def set_w(self, w) -> None:
        self._w = w

    def get_w(self):
        return self._w

    def check(self) -> None:
        # Проверка полученных частей ключа
        expected_value = (G ** self.get_value()) * (H ** self.get_w())
        list_for_check = list()
        for power, val in enumerate(self.get_verify_values()):
            list_for_check.append(pow(val, pow(self.get_point(), power)))
        checking_value = multiply_list_elements(list_for_check)
        if not expected_value == checking_value:
            logger.info('VERIFICATION FAILED')
        else:
            logger.info('VERIFICATION SUCCESSFUL')

    def get_eq(self):
        # генерируем соответствующее уравнение
        eq = [1]
        for power in range(1, self._t):
            eq.append(self._point ** power)
        return eq, [self._value]


if __name__ == "__main__":
    key_sharing()
