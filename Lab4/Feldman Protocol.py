from Crypto.Util.number import getStrongPrime
from GET_PARAMS import get_params_for_feldman
from random import randint, sample
from functools import reduce
import logging
from GET_KEY import get_key_by_eq, get_key_by_lagrange_interpolation

logging.basicConfig(level=logging.INFO, format="[%(levelname)s] %(message)s")
logger = logging.getLogger("Feldman Protocol")

T = 6
N = 12
Q = getStrongPrime(512)
LENGTH_P = 1024
P, G, = get_params_for_feldman(Q, LENGTH_P)


def create_users(N):
    # Создаем пользователей
    users = list()
    for _ in range(N):
        users.append(FeldmanUser(T, N))
    return users


def set_user_points(users, dealer) -> None:
    # Иницилизация точек среди пользователей
    for index, user in enumerate(users):
        point = dealer.get_point(index)
        user.set_point(point)


def set_params(dealer, users) -> None:
    # Задаем коэффициенты и значения, по факту выбираем многочлен
    dealer.set_coefficients()
    dealer.set_values()
    dealer.set_verify_values()

    for index, user in enumerate(users):
        verify_values = dealer.get_verify_values()
        user.set_verify_values(verify_values)
        point = dealer.get_value(index)
        user.set_value(point)


def custom_validation(users) -> None:
    # Проверяем полученные части ключа
    for user in users:
        user.check()


def restore_keys(users, dealer, T):
    # восстанавливаем ключ двумя методами
    # сообщаем об успехе/провале
    def print_results(resp):
        if resp:
            logger.info("Key assembly completed successfully")
            logger.info(f"Received key: {result}")
            logger.info(f"Generated by dealer key: {dealer.get_key()}")
        else:
            logger.info("The resulting key is different from the generated one")
            logger.info(f"Received key: {result}")
            logger.info(f"Generated by dealer key: {dealer.get_key()}")
    users_for_verify = sample(users, T)
    logger.info("SOLVING EQUATIONS")
    result = get_key_by_eq(users_for_verify, Q)
    if result:
        print_results(result == dealer.get_key())
    logger.info("LAGRANGE INTERPOLATION")
    result = get_key_by_lagrange_interpolation(users_for_verify, Q)
    print_results(result == dealer.get_key())


def key_sharing():
    # разделям секрет и собираем
    dealer = FeldmanDealer(T, N)
    users = create_users(N)
    dealer.set_points()
    set_user_points(users, dealer)
    set_params(dealer, users)
    custom_validation(users)
    restore_keys(users, dealer, T)
    logger.info("-" * 100)
    restore_keys(users, dealer, T - 1)


def multiply_list_elements(data):
    # перемножаем элементы в списке
    return reduce(lambda x, y: x * y, data)


class FeldmanDealer:
    # класс дилера
    def __init__(self, t, n):
        self._t = t
        self._n = n
        self._key = None
        self._points = list()
        self._coefficients = list()
        self._values = list()
        self._verify_values = list()

    def set_points(self):
        # задаем точки
        for point in range(1, self._n + 1):
            self._points.append(point)

    def get_point(self, index):
        return self._points[index]

    @staticmethod
    def get_random_element(P):
        return randint(2, P - 2)

    def set_key(self):
        self._key = self.get_random_element(Q)

    def get_key(self):
        return self._key

    def get_value(self, index):

        return self._values[index]

    def set_coefficients(self):
        # генерируем коэффициенты
        self.set_key()
        self._coefficients.append(self._key)
        for _ in range(self._t - 1):
            self._coefficients.append(self.get_random_element(Q))

    def get_coefficients(self):
        return self._coefficients

    def set_values(self):
        # вычисляем значения по полученным коэффициентам
        for point in self._points:
            prev = list()
            for power, coefficient in enumerate(self._coefficients):
                prev.append(coefficient * (point ** power))
            self._values.append(sum(prev) % Q)

    def set_verify_values(self):
        # задаем проверочные значения
        for coefficient in self._coefficients:
            self._verify_values.append(G ** coefficient)

    def get_verify_values(self):
        return self._verify_values


class FeldmanUser:
    # класс пользователя
    def __init__(self, t, n):
        self._t = t
        self._n = n
        self._point = None
        self._value = None
        self._verify_values = None

    def set_point(self, point):
        self._point = point

    def get_point(self):
        return self._point

    def set_value(self, value):
        self._value = value

    def get_value(self):
        return self._value

    def set_verify_values(self, verify_values):
        # получаем проверочные значения
        self._verify_values = verify_values

    def get_verify_values(self):
        return self._verify_values

    def check(self):
        # Проверка полученных частей ключа
        expected_value = G ** self.get_value()
        list_for_check = list()
        for power, val in enumerate(self.get_verify_values()):
            list_for_check.append(pow(val, pow(self.get_point(), power)))
        checking_value = multiply_list_elements(list_for_check)
        if expected_value == checking_value:
            logger.info(f'Verification Success!')
        else:
            logger.info(f"Verification failed")

    def get_eq(self):
        # генерируем соответствующее уравнение
        eq = [1]
        for power in range(1, self._t):
            eq.append(self._point ** power)
        return eq, [self._value]


if __name__ == "__main__":
    key_sharing()
